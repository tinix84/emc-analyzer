<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMC Analyzer - WASM Integration</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .status-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        select, input, button {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
        }
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            background: #888;
            cursor: not-allowed;
            transform: none;
        }
        .chart-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        .error { color: #ff6b6b; }
        .success { color: #51cf66; }
        .loading { color: #ffd43b; }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <!-- Header -->
            <div class="header">
                <h1>üî¨ EMC Analyzer</h1>
                <p>WebAssembly-powered EMC compliance testing</p>
            </div>

            <!-- Status Panel -->
            <div class="status-panel">
                <h3>System Status</h3>
                <p :class="getStatusClass()">{{ statusMessage }}</p>
                <p v-if="wasmLoaded">‚úÖ WASM Module Ready</p>
                <p v-if="currentStandard">‚úÖ Standard Loaded: {{ currentStandard.name }}</p>
            </div>

            <!-- Controls -->
            <div class="controls">
                <!-- Standard Selection -->
                <div class="control-panel">
                    <h3>üìã Select EMC Standard</h3>
                    <div class="form-group">
                        <label for="standard">Standard:</label>
                        <select id="standard" v-model="selectedStandard" @change="onStandardChange">
                            <option value="">-- Select Standard --</option>
                            <option v-for="std in availableStandards" :key="std" :value="std">{{ std }}</option>
                        </select>
                    </div>
                    <div class="form-group" v-if="availableClasses.length > 0">
                        <label for="class">Class:</label>
                        <select id="class" v-model="selectedClass" @change="loadStandard">
                            <option value="">-- Select Class --</option>
                            <option v-for="cls in availableClasses" :key="cls" :value="cls">{{ cls }}</option>
                        </select>
                    </div>
                    <button @click="loadStandard" :disabled="!selectedStandard || !selectedClass">
                        Load Standard
                    </button>
                </div>

                <!-- Data Upload -->
                <div class="control-panel">
                    <h3>üìä Upload Measurement Data</h3>
                    <div class="form-group">
                        <label for="csvFile">CSV File:</label>
                        <input type="file" id="csvFile" @change="handleFileUpload" accept=".csv" />
                    </div>
                    <div class="form-group">
                        <label for="measurementType">Measurement Type:</label>
                        <select id="measurementType" v-model="measurementType">
                            <option value="avg">Average (AVG)</option>
                            <option value="qp">Quasi-Peak (QP)</option>
                            <option value="pk">Peak (PK)</option>
                        </select>
                    </div>
                    <button @click="analyzeMeasurements" :disabled="!measurementData.length || !currentStandard">
                        Analyze Compliance
                    </button>
                </div>
            </div>

            <!-- Chart -->
            <div class="chart-container" v-if="chartData">
                <h3>üìà EMC Analysis Chart</h3>
                <div class="chart-wrapper">
                    <canvas ref="chartCanvas"></canvas>
                </div>
                <div style="margin-top: 15px;">
                    <label>
                        <input type="checkbox" v-model="showLimits" @change="updateChart"> Show Limit Masks
                    </label>
                    <label style="margin-left: 20px;">
                        <input type="checkbox" v-model="showMeasurements" @change="updateChart"> Show Measurements
                    </label>
                </div>
            </div>

            <!-- Results -->
            <div class="control-panel" v-if="complianceResults.length > 0">
                <h3>‚úÖ Compliance Results</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table style="width: 100%; color: black; background: white; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f0f0f0;">
                                <th style="padding: 8px; border: 1px solid #ddd;">Frequency (Hz)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Amplitude (dB¬µV)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Limit (dB¬µV)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Margin (dB)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr v-for="result in complianceResults" :key="result.frequency" 
                                :style="{ background: result.passes ? '#e8f5e8' : '#ffe8e8' }">
                                <td style="padding: 8px; border: 1px solid #ddd;">{{ formatFrequency(result.frequency) }}</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">{{ result.amplitude.toFixed(2) }}</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">{{ result.limit.toFixed(2) }}</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">{{ result.margin.toFixed(2) }}</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">
                                    {{ result.passes ? '‚úÖ PASS' : '‚ùå FAIL' }}
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        const { createApp, ref, onMounted, nextTick } = Vue;

        createApp({
            setup() {
                // Reactive state
                const wasmLoaded = ref(false);
                const statusMessage = ref('Initializing...');
                const wasm = ref(null);
                
                const availableStandards = ref([]);
                const availableClasses = ref([]);
                const selectedStandard = ref('');
                const selectedClass = ref('');
                const currentStandard = ref(null);
                
                const measurementData = ref([]);
                const measurementType = ref('avg');
                const complianceResults = ref([]);
                
                const chartData = ref(null);
                const chart = ref(null);
                const showLimits = ref(true);
                const showMeasurements = ref(true);

                // Load WASM module
                const loadWasmModule = async () => {
                    try {
                        console.log('Loading WASM module...');
                        const wasmModule = await import('./wasm/emc_wasm.js');
                        await wasmModule.default();
                        wasm.value = wasmModule;
                        wasmLoaded.value = true;
                        statusMessage.value = 'WASM module loaded successfully!';
                        console.log('WASM module loaded');
                        
                        // Load available standards
                        await loadAvailableStandards();
                    } catch (error) {
                        console.error('Failed to load WASM module:', error);
                        statusMessage.value = `Failed to load WASM module: ${error.message}`;
                    }
                };

                // Load available standards
                const loadAvailableStandards = async () => {
                    try {
                        const standardsResult = await wasm.value.list_available_standards();
                        availableStandards.value = standardsResult;
                        console.log('Available standards:', standardsResult);
                    } catch (error) {
                        console.error('Failed to load standards:', error);
                        statusMessage.value = `Failed to load standards: ${error.message}`;
                    }
                };

                // Handle standard selection change
                const onStandardChange = async () => {
                    if (!selectedStandard.value) {
                        availableClasses.value = [];
                        return;
                    }
                    
                    try {
                        const classesResult = await wasm.value.list_standard_classes(selectedStandard.value);
                        availableClasses.value = classesResult;
                        selectedClass.value = '';
                        console.log('Available classes:', classesResult);
                    } catch (error) {
                        console.error('Failed to load classes:', error);
                        statusMessage.value = `Failed to load classes: ${error.message}`;
                    }
                };

                // Load selected standard
                const loadStandard = async () => {
                    if (!selectedStandard.value || !selectedClass.value) return;
                    
                    try {
                        statusMessage.value = 'Loading standard...';
                        const standardResult = await wasm.value.get_emc_standard(
                            selectedStandard.value, 
                            selectedClass.value
                        );
                        currentStandard.value = standardResult;
                        statusMessage.value = `Standard loaded: ${standardResult.name}`;
                        console.log('Standard loaded:', standardResult);
                        
                        // Generate limit mask for chart
                        await generateLimitMask();
                    } catch (error) {
                        console.error('Failed to load standard:', error);
                        statusMessage.value = `Failed to load standard: ${error.message}`;
                    }
                };

                // Generate limit mask for visualization
                const generateLimitMask = async () => {
                    if (!currentStandard.value) return;
                    
                    try {
                        const standardJson = JSON.stringify(currentStandard.value);
                        const maskResult = await wasm.value.generate_emc_mask(
                            standardJson,
                            150000,  // 150 kHz
                            30000000, // 30 MHz
                            10        // points per decade
                        );
                        
                        chartData.value = {
                            limits: maskResult,
                            measurements: measurementData.value
                        };
                        
                        await nextTick();
                        createChart();
                    } catch (error) {
                        console.error('Failed to generate mask:', error);
                    }
                };

                // Handle file upload
                const handleFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const csv = e.target.result;
                            const lines = csv.split('\n').filter(line => line.trim());
                            const data = [];
                            
                            // Skip header line and parse data
                            for (let i = 1; i < lines.length; i++) {
                                const [freq, amp] = lines[i].split(',').map(v => parseFloat(v.trim()));
                                if (!isNaN(freq) && !isNaN(amp)) {
                                    data.push({ frequency: freq, amplitude: amp });
                                }
                            }
                            
                            measurementData.value = data;
                            statusMessage.value = `Loaded ${data.length} measurement points`;
                            
                            if (chartData.value) {
                                chartData.value.measurements = data;
                                updateChart();
                            }
                        } catch (error) {
                            console.error('Failed to parse CSV:', error);
                            statusMessage.value = `Failed to parse CSV: ${error.message}`;
                        }
                    };
                    reader.readAsText(file);
                };

                // Analyze measurements for compliance
                const analyzeMeasurements = async () => {
                    if (!currentStandard.value || measurementData.value.length === 0) return;
                    
                    try {
                        statusMessage.value = 'Analyzing compliance...';
                        
                        const frequencies = measurementData.value.map(d => d.frequency);
                        const amplitudes = measurementData.value.map(d => d.amplitude);
                        const standardJson = JSON.stringify(currentStandard.value);
                        
                        const results = await wasm.value.check_emc_compliance(
                            standardJson,
                            frequencies,
                            amplitudes,
                            measurementType.value
                        );
                        
                        complianceResults.value = results;
                        
                        const passCount = results.filter(r => r.passes).length;
                        const totalCount = results.length;
                        statusMessage.value = `Analysis complete: ${passCount}/${totalCount} points pass`;
                        
                        console.log('Compliance results:', results);
                    } catch (error) {
                        console.error('Failed to analyze compliance:', error);
                        statusMessage.value = `Analysis failed: ${error.message}`;
                    }
                };

                // Chart creation and management
                const createChart = () => {
                    const canvas = document.querySelector('canvas');
                    if (!canvas || !chartData.value) return;
                    
                    if (chart.value) {
                        chart.value.destroy();
                    }
                    
                    const ctx = canvas.getContext('2d');
                    
                    const datasets = [];
                    
                    // Add limit lines
                    if (showLimits.value && chartData.value.limits) {
                        if (chartData.value.limits.avg) {
                            datasets.push({
                                label: 'AVG Limit',
                                data: chartData.value.limits.avg.map(p => ({x: p.frequency, y: p.amplitude})),
                                borderColor: 'red',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0
                            });
                        }
                        
                        if (chartData.value.limits.qp) {
                            datasets.push({
                                label: 'QP Limit',
                                data: chartData.value.limits.qp.map(p => ({x: p.frequency, y: p.amplitude})),
                                borderColor: 'orange',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                borderDash: [10, 5],
                                pointRadius: 0
                            });
                        }
                    }
                    
                    // Add measurement data
                    if (showMeasurements.value && chartData.value.measurements) {
                        datasets.push({
                            label: 'Measurements',
                            data: chartData.value.measurements.map(p => ({x: p.frequency, y: p.amplitude})),
                            borderColor: 'blue',
                            backgroundColor: 'blue',
                            borderWidth: 2,
                            pointRadius: 3
                        });
                    }
                    
                    chart.value = new Chart(ctx, {
                        type: 'line',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'logarithmic',
                                    title: {
                                        display: true,
                                        text: 'Frequency (Hz)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Amplitude (dB¬µV)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true
                                }
                            }
                        }
                    });
                };

                const updateChart = () => {
                    if (chart.value && chartData.value) {
                        createChart();
                    }
                };

                // Utility functions
                const getStatusClass = () => {
                    if (statusMessage.value.includes('Error') || statusMessage.value.includes('Failed')) {
                        return 'error';
                    }
                    if (statusMessage.value.includes('Loading') || statusMessage.value.includes('Initializing')) {
                        return 'loading';
                    }
                    return 'success';
                };

                const formatFrequency = (freq) => {
                    if (freq >= 1e6) return `${(freq / 1e6).toFixed(2)} MHz`;
                    if (freq >= 1e3) return `${(freq / 1e3).toFixed(2)} kHz`;
                    return `${freq.toFixed(2)} Hz`;
                };

                // Initialize on mount
                onMounted(() => {
                    loadWasmModule();
                });

                return {
                    wasmLoaded,
                    statusMessage,
                    availableStandards,
                    availableClasses,
                    selectedStandard,
                    selectedClass,
                    currentStandard,
                    measurementData,
                    measurementType,
                    complianceResults,
                    chartData,
                    showLimits,
                    showMeasurements,
                    onStandardChange,
                    loadStandard,
                    handleFileUpload,
                    analyzeMeasurements,
                    updateChart,
                    getStatusClass,
                    formatFrequency
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
